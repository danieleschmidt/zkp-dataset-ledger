# Disaster Recovery and Business Continuity Configuration
# Comprehensive DR planning for ZKP Dataset Ledger

[recovery_objectives]
# Recovery Time Objective (RTO) and Recovery Point Objective (RPO)

# Service tiers and their recovery requirements
service_tiers = [
    {
        name = "critical",
        description = "Core ZKP operations and ledger integrity",
        rto = "15m",           # Must recover within 15 minutes
        rpo = "1m",            # Max 1 minute of data loss
        availability = 99.95   # 99.95% uptime requirement
    },
    {
        name = "important", 
        description = "Storage backends and API services",
        rto = "1h",
        rpo = "5m", 
        availability = 99.9
    },
    {
        name = "standard",
        description = "Reporting and analytics features", 
        rto = "4h",
        rpo = "15m",
        availability = 99.5
    }
]

# Business impact classifications
impact_levels = [
    {level = "critical", description = "Complete service unavailability"},
    {level = "high", description = "Significant feature degradation"},
    {level = "medium", description = "Minor feature impact"},
    {level = "low", description = "Cosmetic or reporting issues"}
]

[backup_strategy]
# Comprehensive backup and archival strategy

# Backup types and schedules
backup_types = [
    {
        name = "continuous_ledger_backup",
        type = "continuous",
        target = "ledger_data",
        interval = "1m",
        retention = "30d",
        encryption = true,
        compression = true
    },
    {
        name = "daily_full_backup",
        type = "full",
        target = "all_data",
        schedule = "daily@02:00",
        retention = "90d",
        encryption = true,
        compression = true
    },
    {
        name = "weekly_archive",
        type = "archive", 
        target = "all_data",
        schedule = "weekly@sunday@01:00",
        retention = "7y",       # Long-term compliance retention
        encryption = true,
        immutable = true
    }
]

# Backup storage locations
storage_locations = [
    {
        name = "primary_backup",
        type = "cloud_storage",
        location = "s3://zkp-ledger-backups-primary/",
        region = "us-west-2",
        encryption_key = "env:BACKUP_ENCRYPTION_KEY"
    },
    {
        name = "secondary_backup", 
        type = "cloud_storage",
        location = "s3://zkp-ledger-backups-secondary/",
        region = "us-east-1",     # Different region for geographic redundancy
        encryption_key = "env:BACKUP_ENCRYPTION_KEY"
    },
    {
        name = "offline_archive",
        type = "cold_storage",
        location = "glacier://zkp-ledger-archives/",
        retrieval_time = "12h",
        encryption_key = "env:ARCHIVE_ENCRYPTION_KEY"
    }
]

# Backup validation
validation = {
    "integrity_checks" = true,
    "test_restores" = "monthly",
    "automated_verification" = true,
    "checksum_validation" = "sha256"
}

[replication]
# Data replication and synchronization

# Database replication
database_replication = [
    {
        name = "postgres_primary",
        type = "primary",
        location = "us-west-2a",
        replicas = [
            {name = "postgres_replica_1", location = "us-west-2b", type = "synchronous"},
            {name = "postgres_replica_2", location = "us-east-1a", type = "asynchronous"}
        ]
    }
]

# Storage replication
storage_replication = [
    {
        name = "rocksdb_primary",
        type = "primary", 
        location = "us-west-2a",
        replication_factor = 3,
        consistency_level = "strong"
    }
]

# Ledger state replication
ledger_replication = {
    "merkle_tree_sync" = "real_time",
    "proof_archive_sync" = "near_real_time", 
    "cross_region_sync" = "asynchronous",
    "conflict_resolution" = "timestamp_ordering"
}

[failover]
# Automated failover procedures

# Failover triggers
triggers = [
    {
        name = "primary_database_failure",
        condition = "database_unavailable > 30s",
        action = "failover_to_replica",
        auto_failback = false   # Manual approval required
    },
    {
        name = "storage_backend_failure", 
        condition = "storage_errors > 10 in 1m",
        action = "switch_storage_backend",
        auto_failback = true
    },
    {
        name = "proof_generation_failure",
        condition = "proof_errors > 50% in 5m",
        action = "restart_service",
        auto_failback = true
    }
]

# Failover procedures
procedures = [
    {
        name = "database_failover",
        steps = [
            "verify_replica_sync_status",
            "promote_replica_to_primary", 
            "update_application_config",
            "restart_application_services",
            "verify_service_health",
            "notify_operations_team"
        ],
        rollback_steps = [
            "demote_current_primary",
            "restore_original_primary",
            "resync_data",
            "switch_back_applications"
        ]
    }
]

# Health checks and monitoring
health_monitoring = {
    "check_interval" = "30s",
    "failure_threshold" = 3,
    "recovery_check_interval" = "10s",
    "notification_channels" = ["slack", "pagerduty", "email"]
}

[recovery_procedures]
# Step-by-step recovery procedures

# Recovery scenarios
scenarios = [
    {
        name = "complete_data_center_failure",
        severity = "critical",
        estimated_rto = "30m",
        estimated_rpo = "5m",
        procedure = "regional_failover_procedure"
    },
    {
        name = "database_corruption",
        severity = "high", 
        estimated_rto = "2h",
        estimated_rpo = "15m",
        procedure = "database_restore_procedure"
    },
    {
        name = "cryptographic_key_compromise",
        severity = "critical",
        estimated_rto = "4h",
        estimated_rpo = "0m",        # No data loss acceptable
        procedure = "key_rotation_procedure"
    },
    {
        name = "ledger_integrity_violation",
        severity = "critical",
        estimated_rto = "1h",
        estimated_rpo = "0m",
        procedure = "ledger_verification_procedure"
    }
]

# Detailed procedures
detailed_procedures = {
    "regional_failover_procedure" = [
        "assess_primary_region_status",
        "verify_secondary_region_readiness", 
        "update_dns_records",
        "redirect_traffic_to_secondary",
        "verify_application_functionality",
        "communicate_status_to_stakeholders"
    ],
    "database_restore_procedure" = [
        "stop_application_services",
        "identify_latest_valid_backup",
        "restore_database_from_backup",
        "verify_data_integrity",
        "replay_transaction_logs",
        "restart_application_services",
        "verify_end_to_end_functionality"
    ]
}

[testing]
# Disaster recovery testing and validation

# Test schedule
test_schedule = [
    {
        name = "monthly_backup_restore_test",
        frequency = "monthly",
        scope = "backup_validation",
        automated = true
    },
    {
        name = "quarterly_failover_test",
        frequency = "quarterly", 
        scope = "full_failover",
        automated = false,      # Requires coordination
        business_impact = "minimal"
    },
    {
        name = "annual_dr_exercise",
        frequency = "annually",
        scope = "complete_disaster_simulation",
        automated = false,
        business_impact = "planned_downtime"
    }
]

# Test validation criteria
test_criteria = [
    "rto_compliance",
    "rpo_compliance", 
    "data_integrity",
    "service_functionality",
    "monitoring_alerting",
    "communication_procedures"
]

# Test documentation
documentation = {
    "test_plans" = "docs/dr-test-plans/",
    "test_results" = "docs/dr-test-results/",
    "lessons_learned" = "docs/dr-lessons-learned/",
    "procedure_updates" = "docs/dr-procedure-updates/"
}

[communication]
# Communication plans and escalation procedures

# Stakeholder groups
stakeholder_groups = [
    {
        name = "executive_team",
        members = ["ceo", "cto", "cfo"],
        notification_threshold = "critical",
        contact_methods = ["phone", "email", "slack"]
    },
    {
        name = "engineering_team",
        members = ["engineering_manager", "senior_engineers", "on_call"],
        notification_threshold = "high",
        contact_methods = ["pagerduty", "slack", "email"]
    },
    {
        name = "customer_success",
        members = ["customer_success_manager", "support_team"],
        notification_threshold = "medium",
        contact_methods = ["slack", "email"]
    }
]

# Communication templates
templates = {
    "initial_incident_notification" = "templates/incident-initial.md",
    "status_update" = "templates/incident-update.md", 
    "resolution_notification" = "templates/incident-resolved.md",
    "post_mortem" = "templates/post-mortem.md"
}

# External communications
external_communication = {
    "status_page" = "https://status.zkp-ledger.com",
    "customer_notification_channels" = ["email", "status_page", "in_app"],
    "regulatory_notification_required" = true,
    "regulatory_notification_timeframe" = "24h"
}

[compliance]
# Regulatory and compliance requirements

# Compliance frameworks
frameworks = [
    {
        name = "SOC2_Type_II",
        requirements = [
            "documented_dr_procedures",
            "regular_dr_testing",
            "incident_response_procedures",
            "data_backup_validation"
        ]
    },
    {
        name = "ISO_27001",
        requirements = [
            "business_continuity_management",
            "information_backup_procedures", 
            "incident_management",
            "supplier_relationships_continuity"
        ]
    },
    {
        name = "GDPR",
        requirements = [
            "data_protection_breach_notification",
            "privacy_by_design_in_dr",
            "data_portability_in_recovery",
            "right_to_be_forgotten_compliance"
        ]
    }
]

# Audit requirements
audit_requirements = {
    "dr_plan_review_frequency" = "annually",
    "test_evidence_retention" = "3y",
    "incident_documentation_retention" = "7y",
    "compliance_reporting_frequency" = "quarterly"
}

[automation]
# Automation and orchestration

# Automation tools
tools = [
    {
        name = "ansible",
        purpose = "infrastructure_automation",
        playbooks = "infrastructure/dr-playbooks/"
    },
    {
        name = "terraform",
        purpose = "infrastructure_provisioning",
        modules = "infrastructure/dr-modules/"
    },
    {
        name = "kubernetes",
        purpose = "application_orchestration", 
        manifests = "k8s/dr-manifests/"
    }
]

# Automated responses
automated_responses = [
    {
        trigger = "database_failure_detected",
        action = "execute_database_failover_playbook",
        approval_required = false
    },
    {
        trigger = "storage_corruption_detected",
        action = "execute_storage_recovery_playbook", 
        approval_required = true
    }
]

# Runbook automation
runbooks = {
    "digital_runbooks" = true,
    "runbook_versioning" = true,
    "runbook_testing" = "automated",
    "runbook_location" = "docs/runbooks/"
}